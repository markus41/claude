---
name: test-component
description: Generate component tests (Vitest/Jest + Testing Library)
argument-hint: "[component-path] [--framework=vitest|jest] [--coverage]"
allowed-tools: ["Read", "Write", "Glob", "Grep", "Bash"]
---

# Component Test Generator

When this command is invoked, generate comprehensive test suites for React components using Vitest or Jest with React Testing Library, including unit tests, integration tests, and edge cases.

## Execution Steps

1. **Analyze Component**
   - Read the component file
   - Parse component props interface
   - Identify component behavior (interactive elements, state, effects)
   - Detect dependencies (contexts, hooks, external services)

2. **Detect Test Framework**
   - Check package.json for vitest or jest
   - Use --framework flag if provided
   - Configure test file naming convention

3. **Generate Test Structure**
   - Create test file with proper imports
   - Generate tests for all props and variants
   - Test user interactions (clicks, typing, etc.)
   - Test edge cases and error states
   - Add Chakra provider wrapper

4. **Optional Coverage Check**
   - If --coverage flag, run tests and show coverage report
   - Identify untested code paths
   - Suggest additional tests for full coverage

## Test Template Structure

```typescript
/**
 * Component tests for [ComponentName]
 *
 * Test categories:
 * - Rendering: Props, variants, conditional rendering
 * - Interactions: User events, state changes
 * - Edge Cases: Error states, loading states, empty states
 * - Accessibility: ARIA attributes, keyboard navigation
 * - Integration: Context, hooks, external dependencies
 *
 * Framework: [Vitest|Jest]
 * Generated by: claude /test-component
 */

import { describe, it, expect, vi, beforeEach } from 'vitest'; // or from '@jest/globals'
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ChakraProvider } from '@chakra-ui/react';
import { ComponentName } from './ComponentName';

/**
 * Test wrapper with Chakra provider
 */
function renderWithChakra(ui: React.ReactElement, options = {}) {
  return render(
    <ChakraProvider>{ui}</ChakraProvider>,
    options
  );
}

describe('ComponentName', () => {
  // Reset mocks before each test
  beforeEach(() => {
    vi.clearAllMocks(); // or jest.clearAllMocks()
  });

  describe('Rendering', () => {
    it('renders without crashing', () => {
      renderWithChakra(<ComponentName />);
      expect(screen.getByTestId('component-name')).toBeInTheDocument();
    });

    it('renders with required props', () => {
      renderWithChakra(<ComponentName title="Test Title" />);
      expect(screen.getByText('Test Title')).toBeInTheDocument();
    });

    it('applies custom className', () => {
      renderWithChakra(<ComponentName className="custom-class" />);
      const element = screen.getByTestId('component-name');
      expect(element).toHaveClass('custom-class');
    });
  });

  describe('Props and Variants', () => {
    it('renders different variants correctly', () => {
      const variants = ['primary', 'secondary', 'outline'] as const;

      variants.forEach(variant => {
        const { rerender } = renderWithChakra(
          <ComponentName variant={variant} />
        );
        // Assert variant-specific styling or behavior
        expect(screen.getByTestId('component-name')).toHaveAttribute(
          'data-variant',
          variant
        );
      });
    });

    it('renders different sizes correctly', () => {
      const sizes = ['sm', 'md', 'lg'] as const;

      sizes.forEach(size => {
        const { rerender } = renderWithChakra(
          <ComponentName size={size} />
        );
        expect(screen.getByTestId('component-name')).toHaveAttribute(
          'data-size',
          size
        );
      });
    });
  });

  describe('User Interactions', () => {
    it('handles click events', async () => {
      const user = userEvent.setup();
      const handleClick = vi.fn();

      renderWithChakra(<ComponentName onClick={handleClick} />);

      await user.click(screen.getByRole('button'));
      expect(handleClick).toHaveBeenCalledTimes(1);
    });

    it('handles keyboard events', async () => {
      const user = userEvent.setup();
      const handleKeyDown = vi.fn();

      renderWithChakra(<ComponentName onKeyDown={handleKeyDown} />);

      const element = screen.getByRole('button');
      element.focus();
      await user.keyboard('{Enter}');

      expect(handleKeyDown).toHaveBeenCalledWith(
        expect.objectContaining({ key: 'Enter' })
      );
    });

    it('updates on user input', async () => {
      const user = userEvent.setup();
      const handleChange = vi.fn();

      renderWithChakra(<ComponentName onChange={handleChange} />);

      const input = screen.getByRole('textbox');
      await user.type(input, 'Hello');

      expect(handleChange).toHaveBeenCalledTimes(5); // Once per character
      expect(input).toHaveValue('Hello');
    });
  });

  describe('State Management', () => {
    it('manages internal state correctly', async () => {
      const user = userEvent.setup();
      renderWithChakra(<ComponentName />);

      const button = screen.getByRole('button', { name: /toggle/i });

      // Initial state
      expect(button).toHaveAttribute('aria-pressed', 'false');

      // After click
      await user.click(button);
      expect(button).toHaveAttribute('aria-pressed', 'true');

      // After second click
      await user.click(button);
      expect(button).toHaveAttribute('aria-pressed', 'false');
    });
  });

  describe('Edge Cases', () => {
    it('handles loading state', () => {
      renderWithChakra(<ComponentName isLoading />);
      expect(screen.getByRole('status')).toBeInTheDocument();
      expect(screen.getByText(/loading/i)).toBeInTheDocument();
    });

    it('handles error state', () => {
      const error = 'Something went wrong';
      renderWithChakra(<ComponentName error={error} />);
      expect(screen.getByRole('alert')).toBeInTheDocument();
      expect(screen.getByText(error)).toBeInTheDocument();
    });

    it('handles empty state', () => {
      renderWithChakra(<ComponentName items={[]} />);
      expect(screen.getByText(/no items/i)).toBeInTheDocument();
    });

    it('handles disabled state', async () => {
      const user = userEvent.setup();
      const handleClick = vi.fn();

      renderWithChakra(<ComponentName isDisabled onClick={handleClick} />);

      const button = screen.getByRole('button');
      expect(button).toBeDisabled();

      await user.click(button);
      expect(handleClick).not.toHaveBeenCalled();
    });
  });

  describe('Conditional Rendering', () => {
    it('shows optional elements when condition is met', () => {
      renderWithChakra(<ComponentName showDetails />);
      expect(screen.getByTestId('details')).toBeInTheDocument();
    });

    it('hides optional elements when condition is not met', () => {
      renderWithChakra(<ComponentName showDetails={false} />);
      expect(screen.queryByTestId('details')).not.toBeInTheDocument();
    });
  });

  describe('Integration', () => {
    it('works with Chakra theme', () => {
      renderWithChakra(<ComponentName colorScheme="brand" />);
      const element = screen.getByTestId('component-name');

      // Check if Chakra styling is applied
      expect(element).toHaveStyle({
        // Assert computed styles from theme
      });
    });

    it('integrates with context', () => {
      const contextValue = { user: { name: 'John' } };

      renderWithChakra(
        <SomeContext.Provider value={contextValue}>
          <ComponentName />
        </SomeContext.Provider>
      );

      expect(screen.getByText('John')).toBeInTheDocument();
    });
  });

  describe('Async Behavior', () => {
    it('handles async operations', async () => {
      const mockFetch = vi.fn().mockResolvedValue({ data: 'test' });

      renderWithChakra(<ComponentName onFetch={mockFetch} />);

      await waitFor(() => {
        expect(mockFetch).toHaveBeenCalled();
      });

      await waitFor(() => {
        expect(screen.getByText('test')).toBeInTheDocument();
      });
    });

    it('handles async errors', async () => {
      const mockFetch = vi.fn().mockRejectedValue(new Error('Fetch failed'));

      renderWithChakra(<ComponentName onFetch={mockFetch} />);

      await waitFor(() => {
        expect(screen.getByText(/fetch failed/i)).toBeInTheDocument();
      });
    });
  });
});
```

## Component-Specific Test Patterns

### Pattern 1: Form Component Tests

```typescript
describe('LoginForm', () => {
  it('validates required fields', async () => {
    const user = userEvent.setup();
    const handleSubmit = vi.fn();

    renderWithChakra(<LoginForm onSubmit={handleSubmit} />);

    // Submit without filling fields
    await user.click(screen.getByRole('button', { name: /submit/i }));

    // Should show validation errors
    expect(screen.getByText(/email is required/i)).toBeInTheDocument();
    expect(screen.getByText(/password is required/i)).toBeInTheDocument();

    // Should not call onSubmit
    expect(handleSubmit).not.toHaveBeenCalled();
  });

  it('submits valid form data', async () => {
    const user = userEvent.setup();
    const handleSubmit = vi.fn();

    renderWithChakra(<LoginForm onSubmit={handleSubmit} />);

    // Fill form
    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');

    // Submit
    await user.click(screen.getByRole('button', { name: /submit/i }));

    // Should call onSubmit with form data
    expect(handleSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    });
  });

  it('disables submit button while submitting', async () => {
    const user = userEvent.setup();
    const handleSubmit = vi.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

    renderWithChakra(<LoginForm onSubmit={handleSubmit} />);

    const submitButton = screen.getByRole('button', { name: /submit/i });

    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(submitButton);

    // Button should be disabled during submission
    expect(submitButton).toBeDisabled();

    await waitFor(() => {
      expect(submitButton).not.toBeDisabled();
    });
  });
});
```

### Pattern 2: Modal/Dialog Tests

```typescript
describe('ConfirmDialog', () => {
  it('opens and closes correctly', async () => {
    const user = userEvent.setup();
    const { rerender } = renderWithChakra(
      <ConfirmDialog isOpen={false} onClose={vi.fn()} />
    );

    // Should not be visible
    expect(screen.queryByRole('dialog')).not.toBeInTheDocument();

    // Open dialog
    rerender(<ConfirmDialog isOpen={true} onClose={vi.fn()} />);

    // Should be visible
    expect(screen.getByRole('dialog')).toBeInTheDocument();
  });

  it('calls onConfirm when confirmed', async () => {
    const user = userEvent.setup();
    const handleConfirm = vi.fn();
    const handleClose = vi.fn();

    renderWithChakra(
      <ConfirmDialog
        isOpen={true}
        onConfirm={handleConfirm}
        onClose={handleClose}
      />
    );

    await user.click(screen.getByRole('button', { name: /confirm/i }));

    expect(handleConfirm).toHaveBeenCalledTimes(1);
    expect(handleClose).toHaveBeenCalledTimes(1);
  });

  it('closes on escape key', async () => {
    const user = userEvent.setup();
    const handleClose = vi.fn();

    renderWithChakra(
      <ConfirmDialog isOpen={true} onClose={handleClose} />
    );

    await user.keyboard('{Escape}');

    expect(handleClose).toHaveBeenCalledTimes(1);
  });
});
```

### Pattern 3: List/Table Component Tests

```typescript
describe('UserTable', () => {
  const mockUsers = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' },
  ];

  it('renders all users', () => {
    renderWithChakra(<UserTable users={mockUsers} />);

    expect(screen.getByText('Alice')).toBeInTheDocument();
    expect(screen.getByText('alice@example.com')).toBeInTheDocument();
    expect(screen.getByText('Bob')).toBeInTheDocument();
    expect(screen.getByText('bob@example.com')).toBeInTheDocument();
  });

  it('sorts by column', async () => {
    const user = userEvent.setup();
    renderWithChakra(<UserTable users={mockUsers} sortable />);

    const nameHeader = screen.getByRole('button', { name: /name/i });

    // First click: ascending
    await user.click(nameHeader);
    const rows = screen.getAllByRole('row');
    expect(rows[1]).toHaveTextContent('Alice');
    expect(rows[2]).toHaveTextContent('Bob');

    // Second click: descending
    await user.click(nameHeader);
    const rowsDesc = screen.getAllByRole('row');
    expect(rowsDesc[1]).toHaveTextContent('Bob');
    expect(rowsDesc[2]).toHaveTextContent('Alice');
  });

  it('filters users', async () => {
    const user = userEvent.setup();
    renderWithChakra(<UserTable users={mockUsers} filterable />);

    const searchInput = screen.getByPlaceholderText(/search/i);
    await user.type(searchInput, 'Alice');

    expect(screen.getByText('Alice')).toBeInTheDocument();
    expect(screen.queryByText('Bob')).not.toBeInTheDocument();
  });
});
```

### Pattern 4: Hook-Based Component Tests

```typescript
describe('useDisclosure-based Component', () => {
  it('toggles visibility', async () => {
    const user = userEvent.setup();

    function TestComponent() {
      const { isOpen, onToggle } = useDisclosure();

      return (
        <>
          <Button onClick={onToggle}>Toggle</Button>
          {isOpen && <Box data-testid="content">Content</Box>}
        </>
      );
    }

    renderWithChakra(<TestComponent />);

    // Initially hidden
    expect(screen.queryByTestId('content')).not.toBeInTheDocument();

    // Toggle on
    await user.click(screen.getByRole('button', { name: /toggle/i }));
    expect(screen.getByTestId('content')).toBeInTheDocument();

    // Toggle off
    await user.click(screen.getByRole('button', { name: /toggle/i }));
    expect(screen.queryByTestId('content')).not.toBeInTheDocument();
  });
});
```

## Mock Patterns

### Mocking Chakra Hooks

```typescript
// Mock useToast
vi.mock('@chakra-ui/react', async () => {
  const actual = await vi.importActual('@chakra-ui/react');
  return {
    ...actual,
    useToast: () => vi.fn(),
  };
});

// Mock useBreakpointValue
vi.mock('@chakra-ui/react', async () => {
  const actual = await vi.importActual('@chakra-ui/react');
  return {
    ...actual,
    useBreakpointValue: (values: any) => values.md, // Always return 'md' breakpoint
  };
});
```

### Mocking API Calls

```typescript
// Mock fetch
global.fetch = vi.fn();

beforeEach(() => {
  (fetch as any).mockResolvedValue({
    ok: true,
    json: async () => ({ data: 'test' }),
  });
});

// Or use MSW (Mock Service Worker)
import { setupServer } from 'msw/node';
import { rest } from 'msw';

const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(ctx.json({ users: mockUsers }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

## Coverage Configuration

### Vitest Coverage

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    coverage: {
      provider: 'v8', // or 'istanbul'
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/mockData/*',
      ],
      all: true,
      lines: 80,
      functions: 80,
      branches: 80,
      statements: 80,
    },
  },
});
```

### Jest Coverage

```javascript
// jest.config.js
module.exports = {
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
    '!src/mockData/**',
  ],
  coverageThresholds: {
    global: {
      lines: 80,
      functions: 80,
      branches: 80,
      statements: 80,
    },
  },
};
```

## Usage Examples

```bash
# Generate tests for a component (auto-detect framework)
claude /test-component src/components/UserProfile.tsx

# Specify framework
claude /test-component src/components/Button.tsx --framework=vitest

# Generate tests with coverage report
claude /test-component src/components/LoginForm.tsx --coverage

# Generate tests for all components in directory
claude /test-component src/components/forms

# Generate and run tests
claude /test-component src/components/Card.tsx && npm test Card.test
```

## Output Format

Generate test file at `[ComponentName].test.tsx` or `[ComponentName].spec.tsx` based on project conventions.

Include a summary comment:

```typescript
/**
 * Test coverage for [ComponentName]:
 * ✅ Rendering with different props
 * ✅ User interactions (click, keyboard, input)
 * ✅ Edge cases (loading, error, empty states)
 * ✅ Accessibility (ARIA attributes, keyboard navigation)
 * ✅ Integration (context, hooks)
 *
 * Run: npm test [ComponentName]
 * Coverage: npm test [ComponentName] -- --coverage
 */
```
