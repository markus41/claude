---
name: post-endpoint
description: Post-endpoint generation hook - automatically generates tests and updates OpenAPI docs
trigger: post-file-write
pattern: "**/router.py"
enabled: true
---

# Post-Endpoint Generation Hook

This hook triggers after a router file is created or modified, automatically generating tests and updating documentation.

## Trigger Conditions

- File matches pattern: `**/router.py` or `**/routes/*.py`
- File contains `@router.` decorator
- File is in `app/domains/` or `app/routes/`

## Actions Performed

1. **Generate Tests** - Create corresponding test file if not exists
2. **Update OpenAPI** - Regenerate OpenAPI schema
3. **Create Postman Collection** - Export endpoint to Postman format
4. **Notify** - Log the new endpoint

## Hook Script

```bash
#!/bin/bash
# hooks/scripts/post-endpoint.sh

set -e

FILE_PATH="$1"
ACTION="$2"  # created, modified

echo "ðŸ”— Post-endpoint hook triggered for: $FILE_PATH"

# Get project root
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
cd "$PROJECT_ROOT"

# Only process router files
if [[ ! "$FILE_PATH" =~ router\.py$ ]] && [[ ! "$FILE_PATH" =~ routes/.*\.py$ ]]; then
    echo "Not a router file, skipping"
    exit 0
fi

# Extract resource name from path
# e.g., app/domains/users/router.py -> users
RESOURCE=$(echo "$FILE_PATH" | grep -oP 'domains/\K[^/]+' || echo "$FILE_PATH" | grep -oP 'routes/\K[^.]+' || echo "")

if [ -z "$RESOURCE" ]; then
    echo "Could not determine resource name"
    exit 0
fi

echo "ðŸ“ Processing resource: $RESOURCE"

# 1. Check if tests exist
TEST_FILE="tests/test_${RESOURCE}.py"
if [ ! -f "$TEST_FILE" ]; then
    echo "ðŸ§ª Test file not found, generating stub..."

    cat > "$TEST_FILE" << 'EOF'
"""
Tests for {RESOURCE} endpoints.

Auto-generated by post-endpoint hook.
TODO: Implement actual test cases.
"""
import pytest
from httpx import AsyncClient


class Test{Resource}Endpoints:
    """Test suite for {Resource} API endpoints."""

    @pytest.mark.asyncio
    async def test_list_{resource}(self, client: AsyncClient):
        """Test listing {resource}."""
        response = await client.get("/api/v1/{resource}/")
        assert response.status_code in [200, 401]

    @pytest.mark.asyncio
    async def test_create_{resource}(self, client: AsyncClient):
        """Test creating {resource}."""
        response = await client.post("/api/v1/{resource}/", json={})
        assert response.status_code in [201, 400, 401, 422]

    @pytest.mark.asyncio
    async def test_get_{resource}(self, client: AsyncClient):
        """Test getting single {resource}."""
        response = await client.get("/api/v1/{resource}/test-id")
        assert response.status_code in [200, 404, 401]

    @pytest.mark.asyncio
    async def test_update_{resource}(self, client: AsyncClient):
        """Test updating {resource}."""
        response = await client.patch("/api/v1/{resource}/test-id", json={})
        assert response.status_code in [200, 404, 401, 422]

    @pytest.mark.asyncio
    async def test_delete_{resource}(self, client: AsyncClient):
        """Test deleting {resource}."""
        response = await client.delete("/api/v1/{resource}/test-id")
        assert response.status_code in [204, 404, 401]
EOF

    # Replace placeholders
    sed -i "s/{RESOURCE}/${RESOURCE^^}/g" "$TEST_FILE"
    sed -i "s/{Resource}/${RESOURCE^}/g" "$TEST_FILE"
    sed -i "s/{resource}/${RESOURCE}/g" "$TEST_FILE"

    echo "âœ… Created test stub: $TEST_FILE"
fi

# 2. Update OpenAPI schema
echo "ðŸ“„ Updating OpenAPI schema..."
if [ -f "scripts/export_openapi.py" ]; then
    python scripts/export_openapi.py > docs/openapi.json 2>/dev/null || true
    echo "âœ… OpenAPI schema updated"
else
    # Create export script if it doesn't exist
    mkdir -p scripts
    cat > scripts/export_openapi.py << 'SCRIPT'
"""Export OpenAPI schema to JSON."""
import json
import sys

try:
    from app.main import app
    schema = app.openapi()
    print(json.dumps(schema, indent=2))
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
SCRIPT
    echo "âš ï¸ Created export script, run manually: python scripts/export_openapi.py"
fi

# 3. Log new endpoints
echo "ðŸ“‹ Analyzing endpoints in $FILE_PATH..."

# Extract endpoint definitions
ENDPOINTS=$(grep -oP '@router\.(get|post|put|patch|delete)\s*\([^)]*\)' "$FILE_PATH" 2>/dev/null || true)

if [ -n "$ENDPOINTS" ]; then
    echo "Found endpoints:"
    echo "$ENDPOINTS" | while read -r endpoint; do
        METHOD=$(echo "$endpoint" | grep -oP '(get|post|put|patch|delete)')
        PATH=$(echo "$endpoint" | grep -oP '"\K[^"]+' | head -1)
        echo "  - ${METHOD^^} /api/v1/${RESOURCE}${PATH}"
    done
fi

# 4. Remind about documentation
echo ""
echo "ðŸ“š Remember to:"
echo "   1. Add docstrings to endpoint functions"
echo "   2. Update README with new endpoints"
echo "   3. Add request/response examples"

echo ""
echo "âœ… Post-endpoint hook completed for: $RESOURCE"
```

## Integration with Claude Code

When Claude Code creates a new router file, this hook can be triggered to ensure:

1. Test scaffolding is in place
2. OpenAPI docs stay current
3. Development workflow is streamlined

## Configuration

```json
{
  "hooks": {
    "post-endpoint": {
      "enabled": true,
      "trigger": "post-file-write",
      "pattern": "**/router.py",
      "script": "hooks/scripts/post-endpoint.sh"
    }
  }
}
```

## Manual Trigger

```bash
# Run manually for existing router
./hooks/scripts/post-endpoint.sh app/domains/users/router.py modified
```

## Test Template Customization

The hook generates test stubs. Customize the template by editing:

```
hooks/templates/test_endpoint.py.tmpl
```

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Tests not generated | Check file path matches pattern |
| OpenAPI fails | Ensure app imports work |
| Wrong resource name | Verify directory structure |
