{
  "hooks": [
    {
      "event": "UserPromptSubmit",
      "name": "detect-jira-issue",
      "description": "Detects Jira issue keys in user messages and provides context",
      "type": "prompt",
      "matcher": {
        "type": "regex",
        "pattern": "\\b[A-Z]{2,10}-\\d+\\b"
      },
      "timeout": 5000,
      "blocking": false,
      "prompt": "# Jira Issue Detection Hook\n\nYou have detected one or more Jira issue keys in the user's message.\n\n## Detected Issues\n\nThe user mentioned: ${DETECTED_ISSUES}\n\n## Your Task\n\n1. **Acknowledge the Jira reference**: Briefly acknowledge that you've noticed the Jira issue key(s)\n\n2. **Provide helpful context**: If the user is asking to work on, fix, implement, or complete the issue, suggest using the `/jira:work` command for a structured orchestrated workflow\n\n3. **Don't be intrusive**: If the user is just mentioning the issue in passing or asking a simple question, don't interrupt their flow. Only suggest orchestration if it seems they want to actually work on the issue.\n\n## Detection Patterns\n\nLook for phrases like:\n- \"work on [ISSUE-KEY]\"\n- \"fix [ISSUE-KEY]\"\n- \"implement [ISSUE-KEY]\"\n- \"complete [ISSUE-KEY]\"\n- \"start [ISSUE-KEY]\"\n- \"help with [ISSUE-KEY]\"\n\n## Example Responses\n\n**User asks to work on issue:**\n> I noticed you mentioned ${DETECTED_ISSUES}. Would you like me to use the `/jira:work` command to orchestrate a complete solution? This will automatically explore the issue, create a plan, implement the code, run tests, fix any issues, and commit the changes.\n\n**User just mentions issue:**\n> I see you're referring to ${DETECTED_ISSUES}. [Then address their actual question without pushing orchestration]\n\n## Important\n\n- Be helpful but not pushy\n- Only suggest orchestration when appropriate\n- Always respect the user's intent\n- Keep responses natural and conversational\n\n## Context Variables\n\n- `${DETECTED_ISSUES}`: Comma-separated list of detected Jira keys\n- `${USER_MESSAGE}`: The full user message\n- `${CLAUDE_PLUGIN_ROOT}`: Plugin root directory"
    },
    {
      "event": "PostToolUse",
      "name": "triage-completion-trigger",
      "description": "Auto-suggests triage analysis after fetching Jira issue details",
      "type": "prompt",
      "matcher": {
        "type": "tool_name",
        "pattern": "jira_get_issue"
      },
      "timeout": 5000,
      "blocking": false,
      "prompt": "# Triage Completion Trigger\n\nYou just fetched Jira issue details using the `jira_get_issue` tool.\n\n## Context\n\n- **Tool Used**: ${TOOL_NAME}\n- **Issue Key**: ${ISSUE_KEY} (extracted from tool arguments)\n- **Session Context**: ${SESSION_CONTEXT}\n\n## Your Task\n\n1. **Check if triage was requested**: Look at the user's original message to see if they want a full analysis\n\n2. **Suggest triage if appropriate**: If the user is trying to understand or work on this issue, suggest running the triage agent:\n\n   > I've fetched the details for ${ISSUE_KEY}. Would you like me to run a comprehensive triage analysis? This will:\n   > - Analyze complexity and risk\n   > - Identify dependencies and blockers\n   > - Recommend the best approach\n   > - Create a detailed implementation plan\n   >\n   > I can do this by invoking the triage-orchestrator agent.\n\n3. **Don't interrupt simple queries**: If the user just wanted to see the issue details, provide them without pushing for triage\n\n4. **Auto-trigger for /jira:work command**: If this was part of a `/jira:work` workflow, automatically proceed with triage\n\n## Helper Script\n\nRun: `${CLAUDE_PLUGIN_ROOT}/hooks/scripts/triage-check.sh ${ISSUE_KEY}` to check if triage is already in progress\n\n## Context Variables\n\n- `${TOOL_NAME}`: The tool that was just used\n- `${TOOL_ARGS}`: Arguments passed to the tool\n- `${TOOL_RESULT}`: Result from the tool\n- `${ISSUE_KEY}`: Extracted Jira issue key\n- `${CLAUDE_PLUGIN_ROOT}`: Plugin root directory"
    },
    {
      "event": "PreToolUse",
      "name": "code-review-gate",
      "description": "Ensures code review passed before creating pull request",
      "type": "prompt",
      "matcher": {
        "type": "tool_name",
        "pattern": "gh_pr_create|mcp__github__create_pull_request"
      },
      "timeout": 10000,
      "blocking": true,
      "prompt": "# Code Review Gate\n\nYou are about to create a pull request using: ${TOOL_NAME}\n\n## CRITICAL CHECK REQUIRED\n\nBefore creating a PR, you MUST verify:\n\n1. **Code Review Completed**: Was a code review performed by the code-reviewer agent?\n2. **Review Status**: Did the code review pass?\n3. **Issues Addressed**: Were all review findings fixed?\n4. **Tests Passing**: Are all tests passing?\n\n## Your Task\n\n### Step 1: Check Review Status\n\nRun the review gate script:\n```bash\n${CLAUDE_PLUGIN_ROOT}/hooks/scripts/review-gate.sh ${JIRA_KEY}\n```\n\nThis will return:\n- `REVIEW_PASSED`: Code review completed and passed\n- `REVIEW_FAILED`: Code review found issues\n- `NO_REVIEW`: No code review was performed\n- `REVIEW_IN_PROGRESS`: Review is currently running\n\n### Step 2: Take Action Based on Result\n\n**If NO_REVIEW**:\n```\nSTOP! Code review has not been performed yet.\n\nBefore creating this PR, I need to run a code review. Let me invoke the code-reviewer agent first.\n\n[Invoke code-reviewer agent]\n```\n\n**If REVIEW_FAILED**:\n```\nSTOP! Code review found issues that need to be fixed.\n\nReview findings:\n[Show review results]\n\nI'll fix these issues before creating the PR.\n\n[Invoke code-fixer or appropriate agent]\n```\n\n**If REVIEW_IN_PROGRESS**:\n```\nCode review is currently in progress. Waiting for completion...\n\n[Wait for review to complete]\n```\n\n**If REVIEW_PASSED**:\n```\nCode review passed! Proceeding with PR creation.\n\n[Allow PR creation to proceed]\n```\n\n## Important\n\n- This is a BLOCKING hook - you cannot proceed with PR creation until review passes\n- Never skip the code review step\n- Always address review findings before creating PR\n- Document the review status in the PR description\n\n## Context Variables\n\n- `${TOOL_NAME}`: The PR creation tool being invoked\n- `${TOOL_ARGS}`: Arguments for PR creation\n- `${JIRA_KEY}`: Current Jira issue being worked on\n- `${CLAUDE_PLUGIN_ROOT}`: Plugin root directory"
    },
    {
      "event": "Stop",
      "name": "documentation-reminder",
      "description": "Reminds to document work if orchestration completed successfully",
      "type": "prompt",
      "timeout": 5000,
      "blocking": false,
      "prompt": "# Documentation Reminder\n\nA session or sub-agent has just completed.\n\n## Context\n\n- **Stop Reason**: ${STOP_REASON}\n- **Session Type**: ${SESSION_TYPE}\n- **Work Completed**: ${WORK_SUMMARY}\n\n## Your Task\n\n### Step 1: Check Documentation Status\n\nRun the documentation check script:\n```bash\n${CLAUDE_PLUGIN_ROOT}/hooks/scripts/docs-reminder.sh ${JIRA_KEY}\n```\n\nThis returns:\n- `DOCS_COMPLETE`: Documentation already created\n- `DOCS_NEEDED`: Work was completed but no docs created\n- `NO_WORK`: No significant work to document\n\n### Step 2: Take Action\n\n**If DOCS_NEEDED**:\n```\nImportant: This work should be documented before closing.\n\nI should:\n1. Create/update documentation in the Obsidian vault\n2. Document key decisions made\n3. Add implementation notes\n4. Update the Jira issue with completion notes\n\nWould you like me to create the documentation now?\n```\n\n**If DOCS_COMPLETE**:\n```\nDocumentation is already up to date.\n```\n\n**If NO_WORK**:\n```\n[No documentation reminder needed]\n```\n\n## Documentation Locations\n\nBased on work type:\n\n**Architecture Decisions**: `${OBSIDIAN_VAULT}/Repositories/${ORG}/${REPO}/Decisions/`\n**Implementation Notes**: `${OBSIDIAN_VAULT}/Repositories/${ORG}/${REPO}/Notes/`\n**Research Findings**: `${OBSIDIAN_VAULT}/Research/`\n**Session Logs**: `${CLAUDE_PLUGIN_ROOT}/sessions/${SESSION_ID}/`\n\n## Important\n\n- Only remind if significant work was completed\n- Don't be intrusive for trivial tasks\n- Suggest using the documentation agent for complex work\n- Always document in Obsidian vault, not project repo\n\n## Context Variables\n\n- `${STOP_REASON}`: Why the session stopped\n- `${SESSION_TYPE}`: Type of session (agent, command, user)\n- `${WORK_SUMMARY}`: Summary of work completed\n- `${JIRA_KEY}`: Current Jira issue (if applicable)\n- `${CLAUDE_PLUGIN_ROOT}`: Plugin root directory\n- `${OBSIDIAN_VAULT}`: Path to Obsidian vault"
    },
    {
      "event": "SessionStart",
      "name": "active-issue-check",
      "description": "Checks for active Jira orchestrations on session start",
      "type": "prompt",
      "timeout": 5000,
      "blocking": false,
      "prompt": "# Active Issue Check\n\nA new Claude Code session has started.\n\n## Your Task\n\n### Step 1: Check for Active Orchestrations\n\nRun the session resume script:\n```bash\n${CLAUDE_PLUGIN_ROOT}/hooks/scripts/session-resume.sh\n```\n\nThis will return:\n- List of active Jira orchestrations\n- Session IDs and issue keys\n- Current phase for each orchestration\n- Time since last activity\n\n### Step 2: Report Active Sessions\n\nIf active sessions found:\n```\nWelcome! I found active Jira orchestrations:\n\n1. **${ISSUE_KEY_1}**: ${ISSUE_SUMMARY}\n   - Phase: ${CURRENT_PHASE}\n   - Status: ${STATUS}\n   - Last Activity: ${TIME_AGO}\n   - Session: ${SESSION_ID}\n\n2. **${ISSUE_KEY_2}**: ${ISSUE_SUMMARY}\n   - Phase: ${CURRENT_PHASE}\n   - Status: ${STATUS}\n   - Last Activity: ${TIME_AGO}\n   - Session: ${SESSION_ID}\n\nWould you like to:\na) Resume one of these orchestrations\nb) View detailed status\nc) Start fresh with a new issue\nd) Clean up stale sessions\n```\n\nIf no active sessions:\n```\nWelcome! No active Jira orchestrations found.\n\nReady to:\n- Start work on a new issue with `/jira:work ISSUE-KEY`\n- View your Jira issues with `/jira:list`\n- Get help with `/jira:help`\n```\n\n### Step 3: Offer Resume Options\n\nIf user wants to resume:\n```\nResuming ${ISSUE_KEY} orchestration...\n\nLast known state:\n- Phase: ${CURRENT_PHASE}\n- Agents completed: ${COMPLETED_AGENTS}\n- Agents pending: ${PENDING_AGENTS}\n- Output location: ${OUTPUT_DIR}\n\nContinuing from where we left off...\n```\n\n## Session Locations\n\n- **Active Sessions**: `${CLAUDE_PLUGIN_ROOT}/sessions/active/`\n- **Session State**: `${CLAUDE_PLUGIN_ROOT}/sessions/${SESSION_ID}/state.json`\n- **Session Logs**: `${CLAUDE_PLUGIN_ROOT}/sessions/${SESSION_ID}/logs/`\n\n## Important\n\n- Only show this check once per session start\n- Don't interrupt if user provides a direct command\n- Be helpful but not pushy about resuming\n- Offer to clean up stale sessions (>24 hours old)\n\n## Context Variables\n\n- `${ACTIVE_SESSIONS}`: List of active session IDs\n- `${ISSUE_KEYS}`: List of active issue keys\n- `${CLAUDE_PLUGIN_ROOT}`: Plugin root directory\n- `${USER}`: Current user\n- `${SESSION_START_TIME}`: When this session started"
    },
    {
      "event": "PreToolUse",
      "name": "pr-size-guard",
      "description": "Checks PR size before creation and blocks or warns if too large",
      "type": "command",
      "matcher": {
        "type": "tool_name",
        "pattern": "gh_pr_create|mcp__github__create_pull_request"
      },
      "timeout": 10000,
      "blocking": true,
      "command": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/pr-size-guard.sh main"
    }
  ],
  "scripts": {
    "detect-jira-key": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/detect-jira-key.sh",
    "triage-check": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/triage-check.sh",
    "review-gate": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/review-gate.sh",
    "docs-reminder": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/docs-reminder.sh",
    "session-resume": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/session-resume.sh",
    "pr-size-guard": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/pr-size-guard.sh",
    "process-pending-worklogs": "${CLAUDE_PLUGIN_ROOT}/hooks/scripts/process-pending-worklogs.sh"
  },
  "auto_time_logging": {
    "enabled": true,
    "description": "Automatically log Claude's command execution time to Jira",
    "config_file": "${CLAUDE_PLUGIN_ROOT}/config/time-logging.yml",
    "processor": "${CLAUDE_PLUGIN_ROOT}/lib/pending_worklog_processor.py"
  }
}
