#!/usr/bin/env python3
"""Build machine-readable and collaboration-ready M365 operational updates."""

from __future__ import annotations

import argparse
import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


def _load_json(path: Path) -> dict[str, Any]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def _derive_resources(payload: dict[str, Any]) -> list[dict[str, Any]]:
    for key in ("resources", "plannedResources", "items", "checks"):
        value = payload.get(key)
        if isinstance(value, list):
            return [item for item in value if isinstance(item, dict)]
    return []


def _resource_status(resource: dict[str, Any], event_type: str) -> str:
    for key in ("health", "status", "gateResult", "readiness"):
        value = resource.get(key)
        if isinstance(value, str) and value.strip():
            return value.strip().lower()
    if event_type == "taia-readiness":
        return "pass"
    return "healthy"


def _priority_for_status(status: str) -> str:
    if status in {"failed", "critical", "fail"}:
        return "high"
    if status in {"degraded", "warning", "blocked"}:
        return "medium"
    return "low"


def _to_machine_output(event_type: str, payload: dict[str, Any]) -> dict[str, Any]:
    resources = _derive_resources(payload)
    normalized = []
    for resource in resources:
        rid = str(resource.get("id") or resource.get("resourceId") or resource.get("name") or "unknown-resource")
        status = _resource_status(resource, event_type)
        normalized.append(
            {
                "resourceId": rid,
                "status": status,
                "owner": resource.get("owner", "unassigned"),
                "slaHours": int(resource.get("slaHours", 8)),
                "evidenceLinks": resource.get("evidenceLinks", []),
                "priority": _priority_for_status(status),
            }
        )

    return {
        "eventType": event_type,
        "generatedAt": datetime.now(timezone.utc).isoformat(),
        "summary": {
            "totalResources": len(normalized),
            "highPriority": sum(1 for r in normalized if r["priority"] == "high"),
            "mediumPriority": sum(1 for r in normalized if r["priority"] == "medium"),
        },
        "teams": {
            "postTemplate": "transitionCheckpointSummary",
            "approvalsRequired": any(r["priority"] == "high" for r in normalized),
        },
        "planner": {
            "upsertTasks": normalized,
        },
        "sharepoint": {
            "checklistUpdates": [
                {
                    "resourceId": r["resourceId"],
                    "status": r["status"],
                    "owner": r["owner"],
                }
                for r in normalized
            ]
        },
    }


def _to_ops_markdown(machine_output: dict[str, Any]) -> str:
    lines = [
        "# TAIA Operational Update",
        "",
        f"- Event: `{machine_output['eventType']}`",
        f"- Generated: `{machine_output['generatedAt']}`",
        f"- Total Resources: **{machine_output['summary']['totalResources']}**",
        f"- High Priority: **{machine_output['summary']['highPriority']}**",
        "",
        "## Teams / Planner Actions",
    ]

    for task in machine_output["planner"]["upsertTasks"]:
        evidence = task["evidenceLinks"] if isinstance(task["evidenceLinks"], list) else []
        links = ", ".join(evidence) if evidence else "none"
        lines.append(
            f"- `{task['resourceId']}` â†’ status **{task['status']}**, owner `{task['owner']}`, SLA `{task['slaHours']}h`, evidence: {links}"
        )

    if machine_output["teams"]["approvalsRequired"]:
        lines.extend(["", "## Approval Notice", "- High-priority items detected; start Buyer/Security approval workflow in Teams."])

    return "\n".join(lines) + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate M365 operational updates from deployment/readiness artifacts.")
    parser.add_argument("--event-type", choices=["status-check", "taia-readiness"], required=True)
    parser.add_argument("--input", required=True, help="Input JSON generated by status-check or taia-readiness.")
    parser.add_argument("--json-out", required=True, help="Output path for machine-readable JSON.")
    parser.add_argument("--ops-out", required=True, help="Output path for collaboration-ready markdown update.")
    args = parser.parse_args()

    source = _load_json(Path(args.input))
    machine = _to_machine_output(args.event_type, source)

    json_out = Path(args.json_out)
    json_out.parent.mkdir(parents=True, exist_ok=True)
    json_out.write_text(json.dumps(machine, indent=2) + "\n", encoding="utf-8")

    ops_out = Path(args.ops_out)
    ops_out.parent.mkdir(parents=True, exist_ok=True)
    ops_out.write_text(_to_ops_markdown(machine), encoding="utf-8")

    print(json.dumps({"jsonOut": str(json_out), "opsOut": str(ops_out), "resources": machine["summary"]["totalResources"]}))


if __name__ == "__main__":
    main()
