/**
 * Template Syntax Detector - Identifies template engine based on syntax patterns
 *
 * Analyzes template content to determine which engine (Handlebars, Jinja2, etc.)
 * should process it, enabling automatic engine selection in the archetype system.
 */

import type { ITemplateSyntaxDetector, SyntaxDetectionResult } from './types.js';

/**
 * Pattern weights for confidence scoring
 */
interface PatternWeight {
  pattern: RegExp;
  weight: number;
  description: string;
}

/**
 * Template syntax detector implementation
 */
export class TemplateSyntaxDetector implements ITemplateSyntaxDetector {
  private handlebarsPatterns: PatternWeight[] = [
    { pattern: /\{\{[^}]+\}\}/g, weight: 1, description: 'Variable syntax {{var}}' },
    { pattern: /\{\{#if\s/g, weight: 2, description: 'If block {{#if}}' },
    { pattern: /\{\{#each\s/g, weight: 2, description: 'Each block {{#each}}' },
    { pattern: /\{\{#unless\s/g, weight: 2, description: 'Unless block {{#unless}}' },
    { pattern: /\{\{#with\s/g, weight: 2, description: 'With block {{#with}}' },
    { pattern: /\{\{>\s*[\w-]+\s*\}\}/g, weight: 2, description: 'Partial {{> partial}}' },
    { pattern: /\{\{!--[\s\S]*?--\}\}/g, weight: 1, description: 'Comment {{!-- --}}' }
  ];

  private jinja2Patterns: PatternWeight[] = [
    { pattern: /\{\{[^}]+\}\}/g, weight: 1, description: 'Variable syntax {{var}}' },
    { pattern: /\{%\s*if\s/g, weight: 3, description: 'If statement {% if %}' },
    { pattern: /\{%\s*for\s/g, weight: 3, description: 'For loop {% for %}' },
    { pattern: /\{%\s*block\s/g, weight: 3, description: 'Block {% block %}' },
    { pattern: /\{%\s*extends\s/g, weight: 3, description: 'Extends {% extends %}' },
    { pattern: /\{%\s*include\s/g, weight: 3, description: 'Include {% include %}' },
    { pattern: /\{%\s*macro\s/g, weight: 3, description: 'Macro {% macro %}' },
    { pattern: /\{%\s*set\s/g, weight: 2, description: 'Set {% set %}' },
    { pattern: /\{#[\s\S]*?#\}/g, weight: 1, description: 'Comment {# #}' },
    { pattern: /\{\{[^}]*\|[^}]*\}\}/g, weight: 2, description: 'Filter {{var|filter}}' }
  ];

  /**
   * Detect which template engine content uses
   */
  detect(content: string): SyntaxDetectionResult {
    const handlebarsScore = this.calculateScore(content, this.handlebarsPatterns);
    const jinja2Score = this.calculateScore(content, this.jinja2Patterns);

    // Determine winner
    if (handlebarsScore.score === 0 && jinja2Score.score === 0) {
      // No template syntax detected
      return {
        engine: 'none',
        confidence: 1,
        patterns: []
      };
    }

    if (jinja2Score.score > handlebarsScore.score) {
      return {
        engine: 'jinja2',
        confidence: this.normalizeConfidence(jinja2Score.score, handlebarsScore.score),
        patterns: jinja2Score.patterns
      };
    } else if (handlebarsScore.score > jinja2Score.score) {
      return {
        engine: 'handlebars',
        confidence: this.normalizeConfidence(handlebarsScore.score, jinja2Score.score),
        patterns: handlebarsScore.patterns
      };
    } else {
      // Tie - prefer Handlebars as default
      return {
        engine: 'handlebars',
        confidence: 0.5,
        patterns: handlebarsScore.patterns
      };
    }
  }

  /**
   * Check if content uses Jinja2 syntax
   * Strong indicator: {% %} blocks which are unique to Jinja2
   */
  isJinja2(content: string): boolean {
    // Check for unique Jinja2 patterns
    const jinja2Unique = [
      /\{%\s*if\s/,
      /\{%\s*for\s/,
      /\{%\s*block\s/,
      /\{%\s*extends\s/,
      /\{%\s*macro\s/,
      /\{#[\s\S]*?#\}/,
      /\{\{[^}]*\|[^}]*\}\}/ // Filters are more common in Jinja2
    ];

    return jinja2Unique.some(pattern => pattern.test(content));
  }

  /**
   * Check if content uses Handlebars syntax
   * Strong indicator: {{# blocks which are unique to Handlebars
   */
  isHandlebars(content: string): boolean {
    // Check for unique Handlebars patterns
    const handlebarsUnique = [
      /\{\{#if\s/,
      /\{\{#each\s/,
      /\{\{#unless\s/,
      /\{\{#with\s/,
      /\{\{>\s*[\w-]+/,
      /\{\{!--[\s\S]*?--\}\}/
    ];

    return handlebarsUnique.some(pattern => pattern.test(content));
  }

  /**
   * Calculate weighted score for pattern matches
   */
  private calculateScore(
    content: string,
    patterns: PatternWeight[]
  ): { score: number; patterns: string[] } {
    let totalScore = 0;
    const matchedPatterns: string[] = [];

    for (const { pattern, weight, description } of patterns) {
      const matches = content.match(pattern);
      if (matches) {
        totalScore += matches.length * weight;
        matchedPatterns.push(description);
      }
    }

    return {
      score: totalScore,
      patterns: matchedPatterns
    };
  }

  /**
   * Normalize confidence score to 0-1 range
   */
  private normalizeConfidence(winnerScore: number, loserScore: number): number {
    if (winnerScore === 0) return 0;
    if (loserScore === 0) return 1;

    const ratio = winnerScore / (winnerScore + loserScore);
    return Math.min(Math.max(ratio, 0), 1);
  }

  /**
   * Detect from file extension
   */
  detectFromExtension(filename: string): string | null {
    const ext = filename.split('.').pop()?.toLowerCase();

    const extensionMap: Record<string, string> = {
      'hbs': 'handlebars',
      'handlebars': 'handlebars',
      'jinja': 'jinja2',
      'jinja2': 'jinja2',
      'j2': 'jinja2'
    };

    return extensionMap[ext || ''] || null;
  }

  /**
   * Comprehensive detection using both content and filename
   */
  detectComprehensive(content: string, filename?: string): SyntaxDetectionResult {
    // First try content-based detection
    const contentDetection = this.detect(content);

    // If high confidence from content, return it
    if (contentDetection.confidence > 0.8) {
      return contentDetection;
    }

    // If low confidence, use filename as tiebreaker
    if (filename) {
      const extensionEngine = this.detectFromExtension(filename);
      if (extensionEngine) {
        return {
          engine: extensionEngine,
          confidence: 0.9,
          patterns: [`File extension: .${filename.split('.').pop()}`]
        };
      }
    }

    return contentDetection;
  }
}

/**
 * Create syntax detector with default configuration
 */
export function createSyntaxDetector(): TemplateSyntaxDetector {
  return new TemplateSyntaxDetector();
}

/**
 * Quick detection helper - returns engine name or null
 */
export function detectEngine(content: string, filename?: string): string | null {
  const detector = createSyntaxDetector();
  const result = detector.detectComprehensive(content, filename);
  return result.engine === 'none' ? null : result.engine;
}
