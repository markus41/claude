/**
 * Notification Channels
 *
 * Multi-channel notification delivery for {{pluginName}}.
 * Supported channels: {{#each channels}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
 */

export interface NotificationPayload {
  id: string;
  type: string;
  title: string;
  message: string;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  data?: Record<string, unknown>;
  recipient?: string;
  channel?: string;
  templateId?: string;
  scheduledAt?: Date;
}

export interface DeliveryResult {
  success: boolean;
  channel: string;
  messageId?: string;
  error?: string;
  deliveredAt: Date;
}

export interface ChannelConfig {
  enabled: boolean;
  priority: number;
  rateLimit?: number;
}

export interface NotificationChannel {
  name: string;
  send(payload: NotificationPayload): Promise<DeliveryResult>;
  isAvailable(): boolean;
}

// Channel implementations
{{#if (includes channels "slack")}}
export { SlackChannel } from './slack';
{{/if}}
{{#if (includes channels "teams")}}
export { TeamsChannel } from './teams';
{{/if}}
{{#if (includes channels "email")}}
export { EmailChannel } from './email';
{{/if}}
{{#if (includes channels "sms")}}
export { SmsChannel } from './sms';
{{/if}}
{{#if (includes channels "webhook")}}
export { WebhookChannel } from './webhook';
{{/if}}
{{#if (includes channels "discord")}}
export { DiscordChannel } from './discord';
{{/if}}
{{#if (includes channels "pagerduty")}}
export { PagerDutyChannel } from './pagerduty';
{{/if}}

/**
 * Channel registry
 */
const channels: Map<string, NotificationChannel> = new Map();

/**
 * Register a notification channel
 */
export function registerChannel(channel: NotificationChannel): void {
  channels.set(channel.name, channel);
}

/**
 * Get a channel by name
 */
export function getChannel(name: string): NotificationChannel | undefined {
  return channels.get(name);
}

/**
 * Get all available channels
 */
export function getAvailableChannels(): NotificationChannel[] {
  return Array.from(channels.values()).filter(c => c.isAvailable());
}

/**
 * Send notification through specified channel
 */
export async function sendToChannel(
  channelName: string,
  payload: NotificationPayload
): Promise<DeliveryResult> {
  const channel = channels.get(channelName);

  if (!channel) {
    return {
      success: false,
      channel: channelName,
      error: `Channel not found: ${channelName}`,
      deliveredAt: new Date(),
    };
  }

  if (!channel.isAvailable()) {
    return {
      success: false,
      channel: channelName,
      error: `Channel not available: ${channelName}`,
      deliveredAt: new Date(),
    };
  }

  return channel.send(payload);
}

{{#if (includes features "fallback")}}
/**
 * Send with fallback to alternate channels
 */
export async function sendWithFallback(
  payload: NotificationPayload,
  channelPriority: string[]
): Promise<DeliveryResult> {
  for (const channelName of channelPriority) {
    const result = await sendToChannel(channelName, payload);
    if (result.success) {
      return result;
    }
    console.warn(`[Notification] Fallback: ${channelName} failed, trying next`);
  }

  return {
    success: false,
    channel: 'all',
    error: 'All channels failed',
    deliveredAt: new Date(),
  };
}
{{/if}}

/**
 * Send to all configured channels
 */
export async function broadcast(
  payload: NotificationPayload
): Promise<DeliveryResult[]> {
  const availableChannels = getAvailableChannels();
  const results = await Promise.all(
    availableChannels.map(channel => channel.send(payload))
  );
  return results;
}
