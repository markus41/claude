/**
 * Webhook Signature Verifier
 *
 * Verifies webhook signatures for {{serviceName}}.
 */

import * as crypto from 'crypto';

export type SignatureType = 'hmac-sha256' | 'hmac-sha1' | 'rsa-sha256' | 'jwt' | 'api-key' | 'none';

/**
 * Verify webhook signature
 */
export function verifySignature(
  payload: unknown,
  signature: string,
  secret: string,
  type: SignatureType
): boolean {
  switch (type) {
    case 'hmac-sha256':
      return verifyHmacSha256(payload, signature, secret);
    case 'hmac-sha1':
      return verifyHmacSha1(payload, signature, secret);
    case 'rsa-sha256':
      return verifyRsaSha256(payload, signature, secret);
    case 'jwt':
      return verifyJwt(signature, secret);
    case 'api-key':
      return verifyApiKey(signature, secret);
    case 'none':
      return true;
    default:
      throw new Error(`Unsupported signature type: ${type}`);
  }
}

/**
 * HMAC-SHA256 verification (GitHub, Stripe style)
 */
function verifyHmacSha256(payload: unknown, signature: string, secret: string): boolean {
  const payloadString = typeof payload === 'string' ? payload : JSON.stringify(payload);
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payloadString)
    .digest('hex');

  // Handle both "sha256=xxx" and raw "xxx" formats
  const providedSig = signature.replace('sha256=', '');

  return crypto.timingSafeEqual(
    Buffer.from(expectedSignature),
    Buffer.from(providedSig)
  );
}

/**
 * HMAC-SHA1 verification (legacy systems)
 */
function verifyHmacSha1(payload: unknown, signature: string, secret: string): boolean {
  const payloadString = typeof payload === 'string' ? payload : JSON.stringify(payload);
  const expectedSignature = crypto
    .createHmac('sha1', secret)
    .update(payloadString)
    .digest('hex');

  const providedSig = signature.replace('sha1=', '');

  return crypto.timingSafeEqual(
    Buffer.from(expectedSignature),
    Buffer.from(providedSig)
  );
}

/**
 * RSA-SHA256 verification (enterprise/Google style)
 */
function verifyRsaSha256(payload: unknown, signature: string, publicKey: string): boolean {
  const payloadString = typeof payload === 'string' ? payload : JSON.stringify(payload);
  const verifier = crypto.createVerify('RSA-SHA256');
  verifier.update(payloadString);

  try {
    return verifier.verify(publicKey, signature, 'base64');
  } catch {
    return false;
  }
}

/**
 * JWT verification
 */
function verifyJwt(token: string, secret: string): boolean {
  try {
    // Extract token from "Bearer xxx" if present
    const jwt = token.replace('Bearer ', '');
    const [headerB64, payloadB64, signatureB64] = jwt.split('.');

    if (!headerB64 || !payloadB64 || !signatureB64) {
      return false;
    }

    // Verify signature
    const signatureInput = `${headerB64}.${payloadB64}`;
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(signatureInput)
      .digest('base64url');

    if (expectedSignature !== signatureB64) {
      return false;
    }

    // Check expiration
    const payload = JSON.parse(Buffer.from(payloadB64, 'base64url').toString());
    if (payload.exp && payload.exp < Date.now() / 1000) {
      return false;
    }

    return true;
  } catch {
    return false;
  }
}

/**
 * Simple API key verification
 */
function verifyApiKey(providedKey: string, expectedKey: string): boolean {
  return crypto.timingSafeEqual(
    Buffer.from(providedKey),
    Buffer.from(expectedKey)
  );
}

/**
 * Utility: Generate HMAC signature for testing
 */
export function generateHmacSignature(
  payload: unknown,
  secret: string,
  algorithm: 'sha256' | 'sha1' = 'sha256'
): string {
  const payloadString = typeof payload === 'string' ? payload : JSON.stringify(payload);
  const signature = crypto
    .createHmac(algorithm, secret)
    .update(payloadString)
    .digest('hex');

  return `${algorithm}=${signature}`;
}
