/**
 * {{serviceName}} Webhook Handler
 *
 * {{description}}
 * Generated from webhook-handler archetype.
 */

import { verifySignature } from './verifier';
import { routeEvent } from './router';
{{#if (includes features "retry-queue")}}
import { RetryQueue } from './retry';
{{/if}}
{{#if (includes features "idempotency")}}
import { IdempotencyStore } from './idempotency';
{{/if}}
import { EventStorage } from './storage';

export interface WebhookPayload {
  headers: Record<string, string>;
  body: unknown;
  timestamp: Date;
  id?: string;
}

export interface WebhookResult {
  success: boolean;
  eventId: string;
  eventType?: string;
  error?: string;
  processed: boolean;
}

export interface HandlerConfig {
  secretKey: string;
  {{#if (includes features "retry-queue")}}
  retryAttempts: number;
  retryDelayMs: number;
  {{/if}}
  {{#if (includes features "rate-limiting")}}
  rateLimit: number;
  rateLimitWindow: number;
  {{/if}}
  storage: EventStorage;
}

/**
 * {{serviceName}}WebhookHandler
 * Processes incoming webhooks with verification and routing
 */
export class {{pascalCase serviceName}}WebhookHandler {
  private config: HandlerConfig;
  {{#if (includes features "retry-queue")}}
  private retryQueue: RetryQueue;
  {{/if}}
  {{#if (includes features "idempotency")}}
  private idempotencyStore: IdempotencyStore;
  {{/if}}

  constructor(config: HandlerConfig) {
    this.config = config;
    {{#if (includes features "retry-queue")}}
    this.retryQueue = new RetryQueue({
      maxAttempts: config.retryAttempts,
      delayMs: config.retryDelayMs,
    });
    {{/if}}
    {{#if (includes features "idempotency")}}
    this.idempotencyStore = new IdempotencyStore();
    {{/if}}
  }

  /**
   * Handle incoming webhook
   */
  async handle(payload: WebhookPayload): Promise<WebhookResult> {
    const eventId = this.extractEventId(payload);

    {{#if (includes features "logging")}}
    console.log(`[{{serviceName}} Webhook] Received event: ${eventId}`);
    {{/if}}

    // Step 1: Verify signature
    const signatureHeader = payload.headers['{{#if (eq signatureType "hmac-sha256")}}x-hub-signature-256{{/if}}{{#if (eq signatureType "hmac-sha1")}}x-hub-signature{{/if}}{{#if (eq signatureType "jwt")}}authorization{{/if}}{{#if (eq signatureType "api-key")}}x-api-key{{/if}}'] || '';

    {{#unless (eq signatureType "none")}}
    const isValid = verifySignature(
      payload.body,
      signatureHeader,
      this.config.secretKey,
      '{{signatureType}}'
    );

    if (!isValid) {
      {{#if (includes features "logging")}}
      console.error(`[{{serviceName}} Webhook] Invalid signature for event: ${eventId}`);
      {{/if}}
      return {
        success: false,
        eventId,
        error: 'Invalid signature',
        processed: false,
      };
    }
    {{/unless}}

    {{#if (includes features "idempotency")}}
    // Step 2: Check idempotency
    if (await this.idempotencyStore.exists(eventId)) {
      {{#if (includes features "logging")}}
      console.log(`[{{serviceName}} Webhook] Duplicate event ignored: ${eventId}`);
      {{/if}}
      return {
        success: true,
        eventId,
        processed: false,
      };
    }
    {{/if}}

    // Step 3: Extract event type
    const eventType = this.extractEventType(payload);

    // Step 4: Store event
    await this.config.storage.store({
      id: eventId,
      type: eventType,
      payload: payload.body,
      receivedAt: payload.timestamp,
      status: 'pending',
    });

    // Step 5: Route and process
    try {
      await routeEvent(eventType, payload.body);

      {{#if (includes features "idempotency")}}
      await this.idempotencyStore.mark(eventId);
      {{/if}}

      await this.config.storage.updateStatus(eventId, 'processed');

      {{#if (includes features "logging")}}
      console.log(`[{{serviceName}} Webhook] Successfully processed: ${eventId}`);
      {{/if}}

      return {
        success: true,
        eventId,
        eventType,
        processed: true,
      };
    } catch (error) {
      {{#if (includes features "retry-queue")}}
      // Queue for retry
      await this.retryQueue.enqueue({
        eventId,
        eventType,
        payload: payload.body,
        error: (error as Error).message,
      });
      {{/if}}

      await this.config.storage.updateStatus(eventId, 'failed', (error as Error).message);

      {{#if (includes features "logging")}}
      console.error(`[{{serviceName}} Webhook] Failed to process: ${eventId}`, error);
      {{/if}}

      return {
        success: false,
        eventId,
        eventType,
        error: (error as Error).message,
        processed: false,
      };
    }
  }

  /**
   * Extract event ID from payload
   */
  private extractEventId(payload: WebhookPayload): string {
    // Try common header patterns
    const headers = payload.headers;
    return (
      headers['x-github-delivery'] ||
      headers['x-request-id'] ||
      headers['x-webhook-id'] ||
      payload.id ||
      `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    );
  }

  /**
   * Extract event type from payload
   */
  private extractEventType(payload: WebhookPayload): string {
    const headers = payload.headers;
    const body = payload.body as Record<string, unknown>;

    // Try common patterns
    return (
      (headers['x-github-event'] as string) ||
      (headers['x-event-type'] as string) ||
      (body.event_type as string) ||
      (body.type as string) ||
      (body.action as string) ||
      'unknown'
    );
  }

  {{#if (includes features "retry-queue")}}
  /**
   * Process retry queue
   */
  async processRetries(): Promise<void> {
    await this.retryQueue.process(async (item) => {
      await routeEvent(item.eventType, item.payload);
      await this.config.storage.updateStatus(item.eventId, 'processed');
    });
  }
  {{/if}}
}

// Export factory function
export function createHandler(secretKey: string): {{pascalCase serviceName}}WebhookHandler {
  return new {{pascalCase serviceName}}WebhookHandler({
    secretKey,
    {{#if (includes features "retry-queue")}}
    retryAttempts: 3,
    retryDelayMs: 1000,
    {{/if}}
    {{#if (includes features "rate-limiting")}}
    rateLimit: 100,
    rateLimitWindow: 60000,
    {{/if}}
    storage: new EventStorage({ type: '{{storage}}' }),
  });
}
