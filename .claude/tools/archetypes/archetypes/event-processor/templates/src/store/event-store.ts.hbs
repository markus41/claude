/**
 * Event Store
 *
 * Persists events to {{persistence}} with support for replay and querying.
 */

import { Event } from '../bus/event-bus';
import * as fs from 'fs';
import * as path from 'path';

export interface EventStoreConfig {
  persistence: '{{persistence}}';
  {{#if (eq persistence "file")}}
  storagePath: string;
  {{/if}}
  {{#if (eq persistence "postgres")}}
  connectionString: string;
  {{/if}}
  {{#if (eq persistence "mongodb")}}
  mongoUri: string;
  database: string;
  {{/if}}
}

export interface EventQuery {
  aggregateId?: string;
  eventTypes?: string[];
  fromTimestamp?: Date;
  toTimestamp?: Date;
  fromVersion?: number;
  limit?: number;
  offset?: number;
}

export interface StoredEvent extends Event {
  storedAt: Date;
  sequenceNumber: number;
}

/**
 * EventStore
 * Persists and retrieves events
 */
export class EventStore {
  private config: EventStoreConfig;
  {{#if (eq persistence "file")}}
  private events: StoredEvent[] = [];
  private sequenceNumber = 0;
  {{/if}}

  constructor(config: EventStoreConfig) {
    this.config = config;
    {{#if (eq persistence "file")}}
    this.loadFromDisk();
    {{/if}}
  }

  /**
   * Append event to store
   */
  async append<T>(event: Event<T>): Promise<StoredEvent> {
    const storedEvent: StoredEvent = {
      ...event,
      storedAt: new Date(),
      sequenceNumber: ++this.sequenceNumber,
    };

    {{#if (eq persistence "file")}}
    this.events.push(storedEvent);
    await this.saveToDisk();
    {{/if}}
    {{#if (eq persistence "memory")}}
    this.events.push(storedEvent);
    {{/if}}

    return storedEvent;
  }

  /**
   * Append multiple events atomically
   */
  async appendAll<T>(events: Event<T>[]): Promise<StoredEvent[]> {
    const storedEvents: StoredEvent[] = events.map(event => ({
      ...event,
      storedAt: new Date(),
      sequenceNumber: ++this.sequenceNumber,
    }));

    {{#if (eq persistence "file")}}
    this.events.push(...storedEvents);
    await this.saveToDisk();
    {{/if}}

    return storedEvents;
  }

  /**
   * Query events
   */
  async query(query: EventQuery): Promise<StoredEvent[]> {
    let results = [...this.events];

    if (query.aggregateId) {
      results = results.filter(e => e.aggregateId === query.aggregateId);
    }

    if (query.eventTypes?.length) {
      results = results.filter(e => query.eventTypes!.includes(e.type));
    }

    if (query.fromTimestamp) {
      results = results.filter(e => e.timestamp >= query.fromTimestamp!);
    }

    if (query.toTimestamp) {
      results = results.filter(e => e.timestamp <= query.toTimestamp!);
    }

    if (query.fromVersion !== undefined) {
      results = results.filter(e => e.version >= query.fromVersion!);
    }

    // Apply pagination
    if (query.offset) {
      results = results.slice(query.offset);
    }

    if (query.limit) {
      results = results.slice(0, query.limit);
    }

    return results;
  }

  /**
   * Get events for an aggregate
   */
  async getByAggregate(aggregateId: string): Promise<StoredEvent[]> {
    return this.query({ aggregateId });
  }

  /**
   * Get events by type
   */
  async getByType(eventType: string): Promise<StoredEvent[]> {
    return this.query({ eventTypes: [eventType] });
  }

  {{#if (includes features "replay")}}
  /**
   * Replay events to a handler
   */
  async replay(
    handler: (event: StoredEvent) => Promise<void>,
    query: EventQuery = {}
  ): Promise<number> {
    const events = await this.query(query);
    let count = 0;

    for (const event of events) {
      await handler(event);
      count++;
    }

    return count;
  }
  {{/if}}

  {{#if (includes features "snapshots")}}
  /**
   * Get latest snapshot for aggregate
   */
  async getSnapshot(aggregateId: string): Promise<unknown | null> {
    // Implementation depends on snapshot storage
    return null;
  }

  /**
   * Save snapshot for aggregate
   */
  async saveSnapshot(aggregateId: string, state: unknown, version: number): Promise<void> {
    // Implementation depends on snapshot storage
  }
  {{/if}}

  /**
   * Get total event count
   */
  async count(query: EventQuery = {}): Promise<number> {
    const events = await this.query({ ...query, limit: undefined, offset: undefined });
    return events.length;
  }

  {{#if (eq persistence "file")}}
  /**
   * Load events from disk
   */
  private loadFromDisk(): void {
    const filePath = path.join(this.config.storagePath, 'events.json');

    if (fs.existsSync(filePath)) {
      const content = fs.readFileSync(filePath, 'utf-8');
      const data = JSON.parse(content);
      this.events = data.events.map((e: StoredEvent) => ({
        ...e,
        timestamp: new Date(e.timestamp),
        storedAt: new Date(e.storedAt),
      }));
      this.sequenceNumber = data.sequenceNumber || this.events.length;
    }
  }

  /**
   * Save events to disk
   */
  private async saveToDisk(): Promise<void> {
    const filePath = path.join(this.config.storagePath, 'events.json');
    const dir = path.dirname(filePath);

    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    const content = JSON.stringify({
      sequenceNumber: this.sequenceNumber,
      events: this.events,
    }, null, 2);

    fs.writeFileSync(filePath, content, 'utf-8');
  }
  {{/if}}
}

// Export factory function
export function createEventStore(storagePath: string = '.claude/event-store'): EventStore {
  return new EventStore({
    persistence: '{{persistence}}',
    {{#if (eq persistence "file")}}
    storagePath,
    {{/if}}
  });
}

// Export singleton
export const eventStore = createEventStore();
